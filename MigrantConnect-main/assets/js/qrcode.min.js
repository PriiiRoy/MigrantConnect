// Enhanced QR Code Library - Functional implementation for MigrantConnect
// Generates unique QR codes based on user data

class QRCode {
    constructor(element, options) {
        this.element = element;
        this.options = options || {};
        this.moduleSize = 8; // Size of each QR module in pixels
        this.size = this.options.width || 200;
        this.modules = Math.floor(this.size / this.moduleSize);
        this.generate();
    }

    generate() {
        // Create QR code container
        const qrDiv = document.createElement('div');
        qrDiv.style.cssText = `
            width: ${this.size}px;
            height: ${this.size}px;
            background: white;
            border: 2px solid #000;
            display: inline-block;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
        `;

        // Generate QR pattern based on user data
        const pattern = this.createQRPattern();
        qrDiv.innerHTML = pattern;

        // Clear existing content and add QR code
        this.element.innerHTML = '';
        this.element.appendChild(qrDiv);
    }

    createQRPattern() {
        const data = this.options.text || 'MigrantConnect';
        const hash = this.createDataHash(data);

        // Create a more realistic QR pattern
        const matrix = this.generateQRMatrix(hash);
        return this.renderMatrix(matrix);
    }

    createDataHash(data) {
        // Create a more sophisticated hash for better uniqueness
        let hash = 0;
        const str = JSON.stringify(data);

        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }

        // Create secondary hash for better distribution
        let hash2 = 0;
        for (let i = str.length - 1; i >= 0; i--) {
            const char = str.charCodeAt(i);
            hash2 = ((hash2 << 3) - hash2) + char;
            hash2 = hash2 & hash2;
        }

        return { primary: Math.abs(hash), secondary: Math.abs(hash2) };
    }

    generateQRMatrix(hash) {
        const size = this.modules;
        const matrix = [];

        // Initialize matrix
        for (let i = 0; i < size; i++) {
            matrix[i] = new Array(size).fill(false);
        }

        // Add finder patterns (corner squares)
        this.addFinderPatterns(matrix, size);

        // Add timing patterns
        this.addTimingPatterns(matrix, size);

        // Add data pattern based on hash
        this.addDataPattern(matrix, size, hash);

        return matrix;
    }

    addFinderPatterns(matrix, size) {
        const positions = [
            [0, 0], // Top-left
            [0, size - 7], // Top-right
            [size - 7, 0] // Bottom-left
        ];

        positions.forEach(([row, col]) => {
            // Outer border
            for (let i = 0; i < 7; i++) {
                for (let j = 0; j < 7; j++) {
                    if (row + i < size && col + j < size) {
                        matrix[row + i][col + j] = (i === 0 || i === 6 || j === 0 || j === 6 ||
                            (i >= 2 && i <= 4 && j >= 2 && j <= 4));
                    }
                }
            }
        });
    }

    addTimingPatterns(matrix, size) {
        // Horizontal timing pattern
        for (let i = 8; i < size - 8; i++) {
            matrix[6][i] = i % 2 === 0;
        }

        // Vertical timing pattern
        for (let i = 8; i < size - 8; i++) {
            matrix[i][6] = i % 2 === 0;
        }
    }

    addDataPattern(matrix, size, hash) {
        const { primary, secondary } = hash;

        // Fill data area with pattern based on hash
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                // Skip finder patterns and timing patterns
                if (this.isReservedArea(i, j, size)) continue;

                // Generate pattern based on position and hash
                const positionHash = (i * size + j);
                const dataValue = (primary + secondary + positionHash) % 3;
                matrix[i][j] = dataValue === 0;
            }
        }
    }

    isReservedArea(row, col, size) {
        // Finder patterns
        if ((row < 9 && col < 9) || // Top-left
            (row < 9 && col >= size - 8) || // Top-right
            (row >= size - 8 && col < 9)) { // Bottom-left
            return true;
        }

        // Timing patterns
        if (row === 6 || col === 6) {
            return true;
        }

        return false;
    }

    renderMatrix(matrix) {
        const size = matrix.length;
        const moduleSize = this.moduleSize;

        let svg = `<svg width="${this.size}" height="${this.size}" xmlns="http://www.w3.org/2000/svg">`;

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (matrix[i][j]) {
                    const x = j * moduleSize;
                    const y = i * moduleSize;
                    svg += `<rect x="${x}" y="${y}" width="${moduleSize}" height="${moduleSize}" fill="#000"/>`;
                }
            }
        }

        svg += '</svg>';
        return svg;
    }

    // Method to get QR data for download
    getQRData() {
        return this.options.text;
    }

    // Method to get QR as image data URL
    toDataURL() {
        const svg = this.element.querySelector('svg');
        if (!svg) return null;

        const svgData = new XMLSerializer().serializeToString(svg);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();

        return new Promise((resolve) => {
            img.onload = () => {
                canvas.width = this.size;
                canvas.height = this.size;
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL('image/png'));
            };
            img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
        });
    }
}

// Correct level enum for compatibility
QRCode.CorrectLevel = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
};

// Make it global
window.QRCode = QRCode;